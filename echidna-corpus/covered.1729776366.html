<style> code { white-space: pre-wrap; display: block; background-color: #eee; }.executed { background-color: #afa; }.reverted { background-color: #ffa; }.unexecuted { background-color: #faa; }.neutral { background-color: #eee; }</style><b>/home/splidge/Github/athena-contracts/flattened/AccessControlDelayed.echidna.sol</b>
<code>
  1 |     | <span class='unexecuted'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity =0.8.24;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;./AccessControlDelayed.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 | *   | <span class='executed'>contract TestToken {</span>
  7 |     | <span class='unexecuted'>    bool public value;</span>
  8 |     | <span class='unexecuted'>    function setValue(bool _value) external {</span>
  9 |     | <span class='unexecuted'>        value = _value;</span>
 10 |     | <span class='neutral'>    }</span>
 11 |     | <span class='neutral'>}</span>
 12 |     | <span class='neutral'></span>
 13 | *r  | <span class='executed'>contract AccessControlDelayedEchidna is AccessControlDelayed {</span>
 14 | *   | <span class='executed'>    TestToken public testToken;</span>
 15 | *   | <span class='executed'>    bytes32 public constant TEST_ROLE = keccak256(&quot;TEST_ROLE&quot;);</span>
 16 |     | <span class='neutral'></span>
 17 | *   | <span class='executed'>    constructor() AccessControlDelayed(1 days) {</span>
 18 | *   | <span class='executed'>        testToken = new TestToken();</span>
 19 | *   | <span class='executed'>        _grantRole(DEFAULT_ADMIN_ROLE, address(this));</span>
 20 |     | <span class='neutral'>    }</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='neutral'>    // Property 1: Roles cannot be granted before delay period</span>
 23 |     | <span class='unexecuted'>    function echidna_no_instant_grant() public view returns (bool) {</span>
 24 |     | <span class='unexecuted'>        bytes32 proposalId = keccak256(abi.encodePacked(TEST_ROLE, address(this)));</span>
 25 |     | <span class='unexecuted'>        return proposedRoles[proposalId] == 0 || block.timestamp &lt; proposedRoles[proposalId];</span>
 26 |     | <span class='neutral'>    }</span>
 27 |     | <span class='neutral'></span>
 28 |     | <span class='neutral'>    // Property 2: Delay cannot exceed 5 days</span>
 29 |     | <span class='unexecuted'>    function echidna_max_delay() public view returns (bool) {</span>
 30 |     | <span class='unexecuted'>        return delay &lt;= 5 days;</span>
 31 |     | <span class='neutral'>    }</span>
 32 |     | <span class='neutral'></span>
 33 |     | <span class='neutral'>    // Property 3: Reduced delay must respect lock time</span>
 34 |     | <span class='unexecuted'>    function echidna_delay_reduction_locked() public view returns (bool) {</span>
 35 |     | <span class='unexecuted'>        if (proposedDelay == 0) return true;</span>
 36 |     | <span class='unexecuted'>        if (proposedDelay &gt;= delay) return true;</span>
 37 |     | <span class='unexecuted'>        return block.timestamp &lt; delayReductionLockTime;</span>
 38 |     | <span class='neutral'>    }</span>
 39 |     | <span class='neutral'></span>
 40 |     | <span class='neutral'>    // Helper function to test role granting</span>
 41 | *   | <span class='executed'>    function tryGrantRole(address account) public {</span>
 42 | *   | <span class='executed'>        try this.grantRole(TEST_ROLE, account) {</span>
 43 |     | <span class='neutral'>            // Role was granted</span>
 44 |     | <span class='neutral'>        } catch {</span>
 45 |     | <span class='neutral'>            // Role grant failed</span>
 46 |     | <span class='neutral'>        }</span>
 47 |     | <span class='neutral'>    }</span>
 48 |     | <span class='neutral'>}</span>
 49 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/splidge/Github/athena-contracts/flattened/AccessControlDelayed.sol</b>
<code>
   1 |     | <span class='neutral'>// Sources flattened with hardhat v2.22.10 https://hardhat.org</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>// File @openzeppelin/contracts/access/IAccessControl.sol@v5.0.2</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>// Original license: SPDX_License_Identifier: MIT</span>
   8 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>/**</span>
  13 |     | <span class='neutral'> * @dev External interface of AccessControl declared to support ERC165 detection.</span>
  14 |     | <span class='neutral'> */</span>
  15 |     | <span class='neutral'>interface IAccessControl {</span>
  16 |     | <span class='neutral'>    /**</span>
  17 |     | <span class='neutral'>     * @dev The `account` is missing a role.</span>
  18 |     | <span class='neutral'>     */</span>
  19 |     | <span class='neutral'>    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);</span>
  20 |     | <span class='neutral'></span>
  21 |     | <span class='neutral'>    /**</span>
  22 |     | <span class='neutral'>     * @dev The caller of a function is not the expected one.</span>
  23 |     | <span class='neutral'>     *</span>
  24 |     | <span class='neutral'>     * NOTE: Don&#39;t confuse with {AccessControlUnauthorizedAccount}.</span>
  25 |     | <span class='neutral'>     */</span>
  26 |     | <span class='neutral'>    error AccessControlBadConfirmation();</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='neutral'>    /**</span>
  29 |     | <span class='neutral'>     * @dev Emitted when `newAdminRole` is set as ``role``&#39;s admin role, replacing `previousAdminRole`</span>
  30 |     | <span class='neutral'>     *</span>
  31 |     | <span class='neutral'>     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite</span>
  32 |     | <span class='neutral'>     * {RoleAdminChanged} not being emitted signaling this.</span>
  33 |     | <span class='neutral'>     */</span>
  34 |     | <span class='neutral'>    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>    /**</span>
  37 |     | <span class='neutral'>     * @dev Emitted when `account` is granted `role`.</span>
  38 |     | <span class='neutral'>     *</span>
  39 |     | <span class='neutral'>     * `sender` is the account that originated the contract call, an admin role</span>
  40 |     | <span class='neutral'>     * bearer except when using {AccessControl-_setupRole}.</span>
  41 |     | <span class='neutral'>     */</span>
  42 |     | <span class='neutral'>    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>    /**</span>
  45 |     | <span class='neutral'>     * @dev Emitted when `account` is revoked `role`.</span>
  46 |     | <span class='neutral'>     *</span>
  47 |     | <span class='neutral'>     * `sender` is the account that originated the contract call:</span>
  48 |     | <span class='neutral'>     *   - if using `revokeRole`, it is the admin role bearer</span>
  49 |     | <span class='neutral'>     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)</span>
  50 |     | <span class='neutral'>     */</span>
  51 |     | <span class='neutral'>    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='neutral'>    /**</span>
  54 |     | <span class='neutral'>     * @dev Returns `true` if `account` has been granted `role`.</span>
  55 |     | <span class='neutral'>     */</span>
  56 |     | <span class='neutral'>    function hasRole(bytes32 role, address account) external view returns (bool);</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='neutral'>    /**</span>
  59 |     | <span class='neutral'>     * @dev Returns the admin role that controls `role`. See {grantRole} and</span>
  60 |     | <span class='neutral'>     * {revokeRole}.</span>
  61 |     | <span class='neutral'>     *</span>
  62 |     | <span class='neutral'>     * To change a role&#39;s admin, use {AccessControl-_setRoleAdmin}.</span>
  63 |     | <span class='neutral'>     */</span>
  64 |     | <span class='neutral'>    function getRoleAdmin(bytes32 role) external view returns (bytes32);</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='neutral'>    /**</span>
  67 |     | <span class='neutral'>     * @dev Grants `role` to `account`.</span>
  68 |     | <span class='neutral'>     *</span>
  69 |     | <span class='neutral'>     * If `account` had not been already granted `role`, emits a {RoleGranted}</span>
  70 |     | <span class='neutral'>     * event.</span>
  71 |     | <span class='neutral'>     *</span>
  72 |     | <span class='neutral'>     * Requirements:</span>
  73 |     | <span class='neutral'>     *</span>
  74 |     | <span class='neutral'>     * - the caller must have ``role``&#39;s admin role.</span>
  75 |     | <span class='neutral'>     */</span>
  76 |     | <span class='neutral'>    function grantRole(bytes32 role, address account) external;</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='neutral'>    /**</span>
  79 |     | <span class='neutral'>     * @dev Revokes `role` from `account`.</span>
  80 |     | <span class='neutral'>     *</span>
  81 |     | <span class='neutral'>     * If `account` had been granted `role`, emits a {RoleRevoked} event.</span>
  82 |     | <span class='neutral'>     *</span>
  83 |     | <span class='neutral'>     * Requirements:</span>
  84 |     | <span class='neutral'>     *</span>
  85 |     | <span class='neutral'>     * - the caller must have ``role``&#39;s admin role.</span>
  86 |     | <span class='neutral'>     */</span>
  87 |     | <span class='neutral'>    function revokeRole(bytes32 role, address account) external;</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='neutral'>    /**</span>
  90 |     | <span class='neutral'>     * @dev Revokes `role` from the calling account.</span>
  91 |     | <span class='neutral'>     *</span>
  92 |     | <span class='neutral'>     * Roles are often managed via {grantRole} and {revokeRole}: this function&#39;s</span>
  93 |     | <span class='neutral'>     * purpose is to provide a mechanism for accounts to lose their privileges</span>
  94 |     | <span class='neutral'>     * if they are compromised (such as when a trusted device is misplaced).</span>
  95 |     | <span class='neutral'>     *</span>
  96 |     | <span class='neutral'>     * If the calling account had been granted `role`, emits a {RoleRevoked}</span>
  97 |     | <span class='neutral'>     * event.</span>
  98 |     | <span class='neutral'>     *</span>
  99 |     | <span class='neutral'>     * Requirements:</span>
 100 |     | <span class='neutral'>     *</span>
 101 |     | <span class='neutral'>     * - the caller must be `callerConfirmation`.</span>
 102 |     | <span class='neutral'>     */</span>
 103 |     | <span class='neutral'>    function renounceRole(bytes32 role, address callerConfirmation) external;</span>
 104 |     | <span class='neutral'>}</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='neutral'>// File @openzeppelin/contracts/utils/Context.sol@v5.0.2</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='neutral'>// Original license: SPDX_License_Identifier: MIT</span>
 110 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='neutral'>/**</span>
 115 |     | <span class='neutral'> * @dev Provides information about the current execution context, including the</span>
 116 |     | <span class='neutral'> * sender of the transaction and its data. While these are generally available</span>
 117 |     | <span class='neutral'> * via msg.sender and msg.data, they should not be accessed in such a direct</span>
 118 |     | <span class='neutral'> * manner, since when dealing with meta-transactions the account sending and</span>
 119 |     | <span class='neutral'> * paying for execution may not be the actual sender (as far as an application</span>
 120 |     | <span class='neutral'> * is concerned).</span>
 121 |     | <span class='neutral'> *</span>
 122 |     | <span class='neutral'> * This contract is only required for intermediate, library-like contracts.</span>
 123 |     | <span class='neutral'> */</span>
 124 |     | <span class='neutral'>abstract contract Context {</span>
 125 | *   | <span class='executed'>    function _msgSender() internal view virtual returns (address) {</span>
 126 | *   | <span class='executed'>        return msg.sender;</span>
 127 |     | <span class='neutral'>    }</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='neutral'>    function _msgData() internal view virtual returns (bytes calldata) {</span>
 130 |     | <span class='neutral'>        return msg.data;</span>
 131 |     | <span class='neutral'>    }</span>
 132 |     | <span class='neutral'></span>
 133 |     | <span class='neutral'>    function _contextSuffixLength() internal view virtual returns (uint256) {</span>
 134 |     | <span class='neutral'>        return 0;</span>
 135 |     | <span class='neutral'>    }</span>
 136 |     | <span class='neutral'>}</span>
 137 |     | <span class='neutral'></span>
 138 |     | <span class='neutral'></span>
 139 |     | <span class='neutral'>// File @openzeppelin/contracts/utils/introspection/IERC165.sol@v5.0.2</span>
 140 |     | <span class='neutral'></span>
 141 |     | <span class='neutral'>// Original license: SPDX_License_Identifier: MIT</span>
 142 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)</span>
 143 |     | <span class='neutral'></span>
 144 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
 145 |     | <span class='neutral'></span>
 146 |     | <span class='neutral'>/**</span>
 147 |     | <span class='neutral'> * @dev Interface of the ERC165 standard, as defined in the</span>
 148 |     | <span class='neutral'> * https://eips.ethereum.org/EIPS/eip-165[EIP].</span>
 149 |     | <span class='neutral'> *</span>
 150 |     | <span class='neutral'> * Implementers can declare support of contract interfaces, which can then be</span>
 151 |     | <span class='neutral'> * queried by others ({ERC165Checker}).</span>
 152 |     | <span class='neutral'> *</span>
 153 |     | <span class='neutral'> * For an implementation, see {ERC165}.</span>
 154 |     | <span class='neutral'> */</span>
 155 |     | <span class='neutral'>interface IERC165 {</span>
 156 |     | <span class='neutral'>    /**</span>
 157 |     | <span class='neutral'>     * @dev Returns true if this contract implements the interface defined by</span>
 158 |     | <span class='neutral'>     * `interfaceId`. See the corresponding</span>
 159 |     | <span class='neutral'>     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]</span>
 160 |     | <span class='neutral'>     * to learn more about how these ids are created.</span>
 161 |     | <span class='neutral'>     *</span>
 162 |     | <span class='neutral'>     * This function call must use less than 30 000 gas.</span>
 163 |     | <span class='neutral'>     */</span>
 164 |     | <span class='neutral'>    function supportsInterface(bytes4 interfaceId) external view returns (bool);</span>
 165 |     | <span class='neutral'>}</span>
 166 |     | <span class='neutral'></span>
 167 |     | <span class='neutral'></span>
 168 |     | <span class='neutral'>// File @openzeppelin/contracts/utils/introspection/ERC165.sol@v5.0.2</span>
 169 |     | <span class='neutral'></span>
 170 |     | <span class='neutral'>// Original license: SPDX_License_Identifier: MIT</span>
 171 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)</span>
 172 |     | <span class='neutral'></span>
 173 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
 174 |     | <span class='neutral'></span>
 175 |     | <span class='neutral'>/**</span>
 176 |     | <span class='neutral'> * @dev Implementation of the {IERC165} interface.</span>
 177 |     | <span class='neutral'> *</span>
 178 |     | <span class='neutral'> * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check</span>
 179 |     | <span class='neutral'> * for the additional interface id that will be supported. For example:</span>
 180 |     | <span class='neutral'> *</span>
 181 |     | <span class='neutral'> * ```solidity</span>
 182 |     | <span class='neutral'> * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {</span>
 183 |     | <span class='neutral'> *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);</span>
 184 |     | <span class='neutral'> * }</span>
 185 |     | <span class='neutral'> * ```</span>
 186 |     | <span class='neutral'> */</span>
 187 |     | <span class='neutral'>abstract contract ERC165 is IERC165 {</span>
 188 |     | <span class='neutral'>    /**</span>
 189 |     | <span class='neutral'>     * @dev See {IERC165-supportsInterface}.</span>
 190 |     | <span class='neutral'>     */</span>
 191 | *   | <span class='executed'>    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {</span>
 192 | *   | <span class='executed'>        return interfaceId == type(IERC165).interfaceId;</span>
 193 |     | <span class='neutral'>    }</span>
 194 |     | <span class='neutral'>}</span>
 195 |     | <span class='neutral'></span>
 196 |     | <span class='neutral'></span>
 197 |     | <span class='neutral'>// File @openzeppelin/contracts/access/AccessControl.sol@v5.0.2</span>
 198 |     | <span class='neutral'></span>
 199 |     | <span class='neutral'>// Original license: SPDX_License_Identifier: MIT</span>
 200 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)</span>
 201 |     | <span class='neutral'></span>
 202 |     | <span class='neutral'>pragma solidity ^0.8.20;</span>
 203 |     | <span class='neutral'></span>
 204 |     | <span class='neutral'></span>
 205 |     | <span class='neutral'></span>
 206 |     | <span class='neutral'>/**</span>
 207 |     | <span class='neutral'> * @dev Contract module that allows children to implement role-based access</span>
 208 |     | <span class='neutral'> * control mechanisms. This is a lightweight version that doesn&#39;t allow enumerating role</span>
 209 |     | <span class='neutral'> * members except through off-chain means by accessing the contract event logs. Some</span>
 210 |     | <span class='neutral'> * applications may benefit from on-chain enumerability, for those cases see</span>
 211 |     | <span class='neutral'> * {AccessControlEnumerable}.</span>
 212 |     | <span class='neutral'> *</span>
 213 |     | <span class='neutral'> * Roles are referred to by their `bytes32` identifier. These should be exposed</span>
 214 |     | <span class='neutral'> * in the external API and be unique. The best way to achieve this is by</span>
 215 |     | <span class='neutral'> * using `public constant` hash digests:</span>
 216 |     | <span class='neutral'> *</span>
 217 |     | <span class='neutral'> * ```solidity</span>
 218 |     | <span class='neutral'> * bytes32 public constant MY_ROLE = keccak256(&quot;MY_ROLE&quot;);</span>
 219 |     | <span class='neutral'> * ```</span>
 220 |     | <span class='neutral'> *</span>
 221 |     | <span class='neutral'> * Roles can be used to represent a set of permissions. To restrict access to a</span>
 222 |     | <span class='neutral'> * function call, use {hasRole}:</span>
 223 |     | <span class='neutral'> *</span>
 224 |     | <span class='neutral'> * ```solidity</span>
 225 |     | <span class='neutral'> * function foo() public {</span>
 226 |     | <span class='neutral'> *     require(hasRole(MY_ROLE, msg.sender));</span>
 227 |     | <span class='neutral'> *     ...</span>
 228 |     | <span class='neutral'> * }</span>
 229 |     | <span class='neutral'> * ```</span>
 230 |     | <span class='neutral'> *</span>
 231 |     | <span class='neutral'> * Roles can be granted and revoked dynamically via the {grantRole} and</span>
 232 |     | <span class='neutral'> * {revokeRole} functions. Each role has an associated admin role, and only</span>
 233 |     | <span class='neutral'> * accounts that have a role&#39;s admin role can call {grantRole} and {revokeRole}.</span>
 234 |     | <span class='neutral'> *</span>
 235 |     | <span class='neutral'> * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means</span>
 236 |     | <span class='neutral'> * that only accounts with this role will be able to grant or revoke other</span>
 237 |     | <span class='neutral'> * roles. More complex role relationships can be created by using</span>
 238 |     | <span class='neutral'> * {_setRoleAdmin}.</span>
 239 |     | <span class='neutral'> *</span>
 240 |     | <span class='neutral'> * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to</span>
 241 |     | <span class='neutral'> * grant and revoke this role. Extra precautions should be taken to secure</span>
 242 |     | <span class='neutral'> * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}</span>
 243 |     | <span class='neutral'> * to enforce additional security measures for this role.</span>
 244 |     | <span class='neutral'> */</span>
 245 |     | <span class='neutral'>abstract contract AccessControl is Context, IAccessControl, ERC165 {</span>
 246 |     | <span class='neutral'>    struct RoleData {</span>
 247 |     | <span class='neutral'>        mapping(address account =&gt; bool) hasRole;</span>
 248 |     | <span class='neutral'>        bytes32 adminRole;</span>
 249 |     | <span class='neutral'>    }</span>
 250 |     | <span class='neutral'></span>
 251 |     | <span class='neutral'>    mapping(bytes32 role =&gt; RoleData) private _roles;</span>
 252 |     | <span class='neutral'></span>
 253 | *   | <span class='executed'>    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;</span>
 254 |     | <span class='neutral'></span>
 255 |     | <span class='neutral'>    /**</span>
 256 |     | <span class='neutral'>     * @dev Modifier that checks that an account has a specific role. Reverts</span>
 257 |     | <span class='neutral'>     * with an {AccessControlUnauthorizedAccount} error including the required role.</span>
 258 |     | <span class='neutral'>     */</span>
 259 |     | <span class='neutral'>    modifier onlyRole(bytes32 role) {</span>
 260 | *   | <span class='executed'>        _checkRole(role);</span>
 261 |     | <span class='neutral'>        _;</span>
 262 |     | <span class='neutral'>    }</span>
 263 |     | <span class='neutral'></span>
 264 |     | <span class='neutral'>    /**</span>
 265 |     | <span class='neutral'>     * @dev See {IERC165-supportsInterface}.</span>
 266 |     | <span class='neutral'>     */</span>
 267 | *   | <span class='executed'>    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {</span>
 268 | *   | <span class='executed'>        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);</span>
 269 |     | <span class='neutral'>    }</span>
 270 |     | <span class='neutral'></span>
 271 |     | <span class='neutral'>    /**</span>
 272 |     | <span class='neutral'>     * @dev Returns `true` if `account` has been granted `role`.</span>
 273 |     | <span class='neutral'>     */</span>
 274 | *   | <span class='executed'>    function hasRole(bytes32 role, address account) public view virtual returns (bool) {</span>
 275 | *   | <span class='executed'>        return _roles[role].hasRole[account];</span>
 276 |     | <span class='neutral'>    }</span>
 277 |     | <span class='neutral'></span>
 278 |     | <span class='neutral'>    /**</span>
 279 |     | <span class='neutral'>     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`</span>
 280 |     | <span class='neutral'>     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.</span>
 281 |     | <span class='neutral'>     */</span>
 282 | *   | <span class='executed'>    function _checkRole(bytes32 role) internal view virtual {</span>
 283 | *   | <span class='executed'>        _checkRole(role, _msgSender());</span>
 284 |     | <span class='neutral'>    }</span>
 285 |     | <span class='neutral'></span>
 286 |     | <span class='neutral'>    /**</span>
 287 |     | <span class='neutral'>     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`</span>
 288 |     | <span class='neutral'>     * is missing `role`.</span>
 289 |     | <span class='neutral'>     */</span>
 290 | *   | <span class='executed'>    function _checkRole(bytes32 role, address account) internal view virtual {</span>
 291 | *   | <span class='executed'>        if (!hasRole(role, account)) {</span>
 292 | *r  | <span class='executed'>            revert AccessControlUnauthorizedAccount(account, role);</span>
 293 |     | <span class='neutral'>        }</span>
 294 |     | <span class='neutral'>    }</span>
 295 |     | <span class='neutral'></span>
 296 |     | <span class='neutral'>    /**</span>
 297 |     | <span class='neutral'>     * @dev Returns the admin role that controls `role`. See {grantRole} and</span>
 298 |     | <span class='neutral'>     * {revokeRole}.</span>
 299 |     | <span class='neutral'>     *</span>
 300 |     | <span class='neutral'>     * To change a role&#39;s admin, use {_setRoleAdmin}.</span>
 301 |     | <span class='neutral'>     */</span>
 302 | *   | <span class='executed'>    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {</span>
 303 | *   | <span class='executed'>        return _roles[role].adminRole;</span>
 304 |     | <span class='neutral'>    }</span>
 305 |     | <span class='neutral'></span>
 306 |     | <span class='neutral'>    /**</span>
 307 |     | <span class='neutral'>     * @dev Grants `role` to `account`.</span>
 308 |     | <span class='neutral'>     *</span>
 309 |     | <span class='neutral'>     * If `account` had not been already granted `role`, emits a {RoleGranted}</span>
 310 |     | <span class='neutral'>     * event.</span>
 311 |     | <span class='neutral'>     *</span>
 312 |     | <span class='neutral'>     * Requirements:</span>
 313 |     | <span class='neutral'>     *</span>
 314 |     | <span class='neutral'>     * - the caller must have ``role``&#39;s admin role.</span>
 315 |     | <span class='neutral'>     *</span>
 316 |     | <span class='neutral'>     * May emit a {RoleGranted} event.</span>
 317 |     | <span class='neutral'>     */</span>
 318 |     | <span class='unexecuted'>    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {</span>
 319 |     | <span class='unexecuted'>        _grantRole(role, account);</span>
 320 |     | <span class='neutral'>    }</span>
 321 |     | <span class='neutral'></span>
 322 |     | <span class='neutral'>    /**</span>
 323 |     | <span class='neutral'>     * @dev Revokes `role` from `account`.</span>
 324 |     | <span class='neutral'>     *</span>
 325 |     | <span class='neutral'>     * If `account` had been granted `role`, emits a {RoleRevoked} event.</span>
 326 |     | <span class='neutral'>     *</span>
 327 |     | <span class='neutral'>     * Requirements:</span>
 328 |     | <span class='neutral'>     *</span>
 329 |     | <span class='neutral'>     * - the caller must have ``role``&#39;s admin role.</span>
 330 |     | <span class='neutral'>     *</span>
 331 |     | <span class='neutral'>     * May emit a {RoleRevoked} event.</span>
 332 |     | <span class='neutral'>     */</span>
 333 | *   | <span class='executed'>    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {</span>
 334 |     | <span class='unexecuted'>        _revokeRole(role, account);</span>
 335 |     | <span class='neutral'>    }</span>
 336 |     | <span class='neutral'></span>
 337 |     | <span class='neutral'>    /**</span>
 338 |     | <span class='neutral'>     * @dev Revokes `role` from the calling account.</span>
 339 |     | <span class='neutral'>     *</span>
 340 |     | <span class='neutral'>     * Roles are often managed via {grantRole} and {revokeRole}: this function&#39;s</span>
 341 |     | <span class='neutral'>     * purpose is to provide a mechanism for accounts to lose their privileges</span>
 342 |     | <span class='neutral'>     * if they are compromised (such as when a trusted device is misplaced).</span>
 343 |     | <span class='neutral'>     *</span>
 344 |     | <span class='neutral'>     * If the calling account had been revoked `role`, emits a {RoleRevoked}</span>
 345 |     | <span class='neutral'>     * event.</span>
 346 |     | <span class='neutral'>     *</span>
 347 |     | <span class='neutral'>     * Requirements:</span>
 348 |     | <span class='neutral'>     *</span>
 349 |     | <span class='neutral'>     * - the caller must be `callerConfirmation`.</span>
 350 |     | <span class='neutral'>     *</span>
 351 |     | <span class='neutral'>     * May emit a {RoleRevoked} event.</span>
 352 |     | <span class='neutral'>     */</span>
 353 | *   | <span class='executed'>    function renounceRole(bytes32 role, address callerConfirmation) public virtual {</span>
 354 | *   | <span class='executed'>        if (callerConfirmation != _msgSender()) {</span>
 355 | *r  | <span class='executed'>            revert AccessControlBadConfirmation();</span>
 356 |     | <span class='neutral'>        }</span>
 357 |     | <span class='neutral'></span>
 358 | *   | <span class='executed'>        _revokeRole(role, callerConfirmation);</span>
 359 |     | <span class='neutral'>    }</span>
 360 |     | <span class='neutral'></span>
 361 |     | <span class='neutral'>    /**</span>
 362 |     | <span class='neutral'>     * @dev Sets `adminRole` as ``role``&#39;s admin role.</span>
 363 |     | <span class='neutral'>     *</span>
 364 |     | <span class='neutral'>     * Emits a {RoleAdminChanged} event.</span>
 365 |     | <span class='neutral'>     */</span>
 366 |     | <span class='neutral'>    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {</span>
 367 |     | <span class='neutral'>        bytes32 previousAdminRole = getRoleAdmin(role);</span>
 368 |     | <span class='neutral'>        _roles[role].adminRole = adminRole;</span>
 369 |     | <span class='neutral'>        emit RoleAdminChanged(role, previousAdminRole, adminRole);</span>
 370 |     | <span class='neutral'>    }</span>
 371 |     | <span class='neutral'></span>
 372 |     | <span class='neutral'>    /**</span>
 373 |     | <span class='neutral'>     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.</span>
 374 |     | <span class='neutral'>     *</span>
 375 |     | <span class='neutral'>     * Internal function without access restriction.</span>
 376 |     | <span class='neutral'>     *</span>
 377 |     | <span class='neutral'>     * May emit a {RoleGranted} event.</span>
 378 |     | <span class='neutral'>     */</span>
 379 | *   | <span class='executed'>    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {</span>
 380 | *   | <span class='executed'>        if (!hasRole(role, account)) {</span>
 381 | *   | <span class='executed'>            _roles[role].hasRole[account] = true;</span>
 382 | *   | <span class='executed'>            emit RoleGranted(role, account, _msgSender());</span>
 383 | *   | <span class='executed'>            return true;</span>
 384 |     | <span class='neutral'>        } else {</span>
 385 |     | <span class='unexecuted'>            return false;</span>
 386 |     | <span class='neutral'>        }</span>
 387 |     | <span class='neutral'>    }</span>
 388 |     | <span class='neutral'></span>
 389 |     | <span class='neutral'>    /**</span>
 390 |     | <span class='neutral'>     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.</span>
 391 |     | <span class='neutral'>     *</span>
 392 |     | <span class='neutral'>     * Internal function without access restriction.</span>
 393 |     | <span class='neutral'>     *</span>
 394 |     | <span class='neutral'>     * May emit a {RoleRevoked} event.</span>
 395 |     | <span class='neutral'>     */</span>
 396 | *   | <span class='executed'>    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {</span>
 397 | *   | <span class='executed'>        if (hasRole(role, account)) {</span>
 398 |     | <span class='unexecuted'>            _roles[role].hasRole[account] = false;</span>
 399 |     | <span class='unexecuted'>            emit RoleRevoked(role, account, _msgSender());</span>
 400 |     | <span class='unexecuted'>            return true;</span>
 401 |     | <span class='neutral'>        } else {</span>
 402 | *   | <span class='executed'>            return false;</span>
 403 |     | <span class='neutral'>        }</span>
 404 |     | <span class='neutral'>    }</span>
 405 |     | <span class='neutral'>}</span>
 406 |     | <span class='neutral'></span>
 407 |     | <span class='neutral'></span>
 408 |     | <span class='neutral'>// File contracts/Errors.sol</span>
 409 |     | <span class='neutral'></span>
 410 |     | <span class='neutral'>// Original license: SPDX_License_Identifier: MIT</span>
 411 |     | <span class='neutral'>pragma solidity =0.8.24;</span>
 412 |     | <span class='neutral'></span>
 413 |     | <span class='neutral'>/// @title Errors</span>
 414 |     | <span class='neutral'>/// @notice This contract contains all custom errors used across the protocol</span>
 415 |     | <span class='unexecuted'>contract Errors {</span>
 416 |     | <span class='neutral'>    // Generic errors</span>
 417 |     | <span class='neutral'>    error InvalidInput(string _contract, string _function);</span>
 418 |     | <span class='neutral'></span>
 419 |     | <span class='neutral'>    // AccessControlDelayed errors</span>
 420 |     | <span class='neutral'>    error AccessControlDelayed_InvalidDelay();</span>
 421 |     | <span class='neutral'></span>
 422 |     | <span class='neutral'>    // AdminVault errors</span>
 423 |     | <span class='neutral'>    error AdminVault_FeePercentageOutOfRange(uint256 _providedPercentage, uint256 _minAllowed, uint256 _maxAllowed);</span>
 424 |     | <span class='neutral'>    error AdminVault_InvalidFeeRange(uint256 _minFee, uint256 _maxFee);</span>
 425 |     | <span class='neutral'>    error AdminVault_AlreadyInitialized();</span>
 426 |     | <span class='neutral'>    error AdminVault_NotInitialized();</span>
 427 |     | <span class='neutral'>    error AdminVault_Unauthorized(address _caller, bytes32 _requiredRole);</span>
 428 |     | <span class='neutral'>    error AdminVault_DelayNotPassed(uint256 _currentTime, uint256 _requiredTime);</span>
 429 |     | <span class='neutral'>    error AdminVault_NotFound(string _entityType, bytes4 _entityId);</span>
 430 |     | <span class='neutral'>    error AdminVault_NotProposed();</span>
 431 |     | <span class='neutral'>    error AdminVault_AlreadyProposed();</span>
 432 |     | <span class='neutral'>    error AdminVault_NotAdded();</span>
 433 |     | <span class='neutral'>    error AdminVault_AlreadyAdded();</span>
 434 |     | <span class='neutral'></span>
 435 |     | <span class='neutral'>    // FeeTakeSafeModule errors</span>
 436 |     | <span class='neutral'>    error FeeTakeSafeModule_SenderNotFeeTaker(address _sender);</span>
 437 |     | <span class='neutral'>    error FeeTakeSafeModule_InvalidActionType(bytes4 _actionId);</span>
 438 |     | <span class='neutral'>    error FeeTakeSafeModule_ExecutionFailed();</span>
 439 |     | <span class='neutral'></span>
 440 |     | <span class='neutral'>    // Generic Action errors</span>
 441 |     | <span class='neutral'>    error Action_ZeroAmount(string _protocolName, uint8 _actionType);</span>
 442 |     | <span class='neutral'>    error Action_InsufficientSharesReceived(</span>
 443 |     | <span class='neutral'>        string _protocolName,</span>
 444 |     | <span class='neutral'>        uint8 _actionType,</span>
 445 |     | <span class='neutral'>        uint256 _sharesReceived,</span>
 446 |     | <span class='neutral'>        uint256 _minSharesReceived</span>
 447 |     | <span class='neutral'>    );</span>
 448 |     | <span class='neutral'>    error Action_MaxSharesBurnedExceeded(</span>
 449 |     | <span class='neutral'>        string _protocolName,</span>
 450 |     | <span class='neutral'>        uint8 _actionType,</span>
 451 |     | <span class='neutral'>        uint256 _sharesBurned,</span>
 452 |     | <span class='neutral'>        uint256 _maxAllowed</span>
 453 |     | <span class='neutral'>    );</span>
 454 |     | <span class='neutral'>    error Action_NotDelegateCall();</span>
 455 |     | <span class='neutral'>    // Curve3PoolSwap errors</span>
 456 |     | <span class='neutral'>    error Curve3Pool__InvalidTokenIndices(int128 _fromToken, int128 _toToken);</span>
 457 |     | <span class='neutral'></span>
 458 |     | <span class='neutral'>    // SendToken errors</span>
 459 |     | <span class='neutral'>    error Action_InvalidRecipient(string _protocolName, uint8 _actionType);</span>
 460 |     | <span class='neutral'>}</span>
 461 |     | <span class='neutral'></span>
 462 |     | <span class='neutral'></span>
 463 |     | <span class='neutral'>// File contracts/auth/AccessControlDelayed.sol</span>
 464 |     | <span class='neutral'></span>
 465 |     | <span class='neutral'>// Original license: SPDX_License_Identifier: MIT</span>
 466 |     | <span class='neutral'></span>
 467 |     | <span class='neutral'>pragma solidity =0.8.24;</span>
 468 |     | <span class='neutral'></span>
 469 |     | <span class='neutral'></span>
 470 |     | <span class='neutral'>/// @title Add delays to granting roles in access control</span>
 471 |     | <span class='neutral'>abstract contract AccessControlDelayed is AccessControl {</span>
 472 | *   | <span class='executed'>    uint256 public delay; // How long after a proposal can the role be granted</span>
 473 | *   | <span class='executed'>    uint256 public proposedDelay; // New delay to be set after delayReductionLockTime</span>
 474 | *   | <span class='executed'>    uint256 public delayReductionLockTime; // Time when the new delay can be set/used</span>
 475 |     | <span class='neutral'>    // mapping of proposed roles to the timestamp they can be granted</span>
 476 | *   | <span class='executed'>    mapping(bytes32 =&gt; uint256) public proposedRoles;</span>
 477 |     | <span class='neutral'></span>
 478 | *   | <span class='executed'>    constructor(uint256 _delay) {</span>
 479 | *   | <span class='executed'>        delay = _delay;</span>
 480 |     | <span class='neutral'>    }</span>
 481 |     | <span class='neutral'></span>
 482 | *   | <span class='executed'>    function grantRoles(bytes32[] calldata roles, address[] calldata accounts) external virtual {</span>
 483 | *   | <span class='executed'>        for (uint256 i = 0; i &lt; roles.length; i++) {</span>
 484 | *   | <span class='executed'>            grantRole(roles[i], accounts[i]);</span>
 485 |     | <span class='neutral'>        }</span>
 486 |     | <span class='neutral'>    }</span>
 487 |     | <span class='neutral'></span>
 488 | *   | <span class='executed'>    function grantRole(bytes32 role, address account) public virtual override(AccessControl) {</span>
 489 | *   | <span class='executed'>        bytes32 proposalId = keccak256(abi.encodePacked(role, account));</span>
 490 |     | <span class='neutral'>        // Check if role was proposed</span>
 491 | *   | <span class='executed'>        if (proposedRoles[proposalId] == 0) {</span>
 492 | *r  | <span class='executed'>            revert Errors.AdminVault_NotProposed();</span>
 493 |     | <span class='neutral'>        }</span>
 494 |     | <span class='neutral'>        // Check if delay is passed</span>
 495 |     | <span class='unexecuted'>        if (block.timestamp &lt; proposedRoles[proposalId]) {</span>
 496 |     | <span class='unexecuted'>            revert Errors.AdminVault_DelayNotPassed(block.timestamp, proposedRoles[proposalId]);</span>
 497 |     | <span class='neutral'>        }</span>
 498 |     | <span class='neutral'>        // role was proposed and delay has passed, delete proposal and grant role</span>
 499 |     | <span class='unexecuted'>        delete proposedRoles[proposalId];</span>
 500 |     | <span class='unexecuted'>        super.grantRole(role, account);</span>
 501 |     | <span class='neutral'>    }</span>
 502 |     | <span class='neutral'></span>
 503 | *   | <span class='executed'>    function proposeRoles(</span>
 504 |     | <span class='neutral'>        bytes32[] calldata roles,</span>
 505 |     | <span class='neutral'>        address[] calldata accounts</span>
 506 | *   | <span class='executed'>    ) external virtual onlyRole(DEFAULT_ADMIN_ROLE) {</span>
 507 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; roles.length; i++) {</span>
 508 |     | <span class='unexecuted'>            _proposeRole(roles[i], accounts[i]);</span>
 509 |     | <span class='neutral'>        }</span>
 510 |     | <span class='neutral'>    }</span>
 511 |     | <span class='neutral'></span>
 512 | *   | <span class='executed'>    function proposeRole(bytes32 role, address account) external virtual onlyRole(DEFAULT_ADMIN_ROLE) {</span>
 513 |     | <span class='unexecuted'>        _proposeRole(role, account);</span>
 514 |     | <span class='neutral'>    }</span>
 515 |     | <span class='neutral'></span>
 516 |     | <span class='unexecuted'>    function _proposeRole(bytes32 role, address account) internal virtual {</span>
 517 |     | <span class='unexecuted'>        if (account == address(0)) {</span>
 518 |     | <span class='unexecuted'>            revert Errors.InvalidInput(&quot;AccessControlDelayed&quot;, &quot;_proposeRole&quot;);</span>
 519 |     | <span class='neutral'>        }</span>
 520 |     | <span class='neutral'>        // Check if role was already proposed</span>
 521 |     | <span class='unexecuted'>        bytes32 proposalId = keccak256(abi.encodePacked(role, account));</span>
 522 |     | <span class='unexecuted'>        if (proposedRoles[proposalId] &gt; 0) {</span>
 523 |     | <span class='unexecuted'>            revert Errors.AdminVault_AlreadyProposed();</span>
 524 |     | <span class='neutral'>        }</span>
 525 |     | <span class='neutral'>        // add to list of proposed roles with the wait time</span>
 526 |     | <span class='unexecuted'>        proposedRoles[proposalId] = _getDelayTimestamp();</span>
 527 |     | <span class='neutral'>    }</span>
 528 |     | <span class='neutral'></span>
 529 |     | <span class='neutral'>    // A helper to find the time when a role proposal will be available to grant</span>
 530 | *   | <span class='executed'>    function getRoleProposalTime(bytes32 role, address account) public view returns (uint256) {</span>
 531 | *   | <span class='executed'>        return proposedRoles[keccak256(abi.encodePacked(role, account))];</span>
 532 |     | <span class='neutral'>    }</span>
 533 |     | <span class='neutral'></span>
 534 |     | <span class='neutral'>    // Admin function to change the delay</span>
 535 |     | <span class='neutral'>    // If the new delay is longer we just use it.</span>
 536 |     | <span class='neutral'>    // If the new delay is shorter we must set a timestamp for when the old delay</span>
 537 |     | <span class='neutral'>    // would have expired and we can use the new delay after that time.</span>
 538 |     | <span class='neutral'>    // e.g. If the delay is 2 hours, and we reduce it to 1 hour. All new proposals</span>
 539 |     | <span class='neutral'>    //      must wait until at least now + 2 hours (old delay) but in 1 hour&#39;s time</span>
 540 |     | <span class='neutral'>    //      they may start using the new delay (because both the old and the new</span>
 541 |     | <span class='neutral'>    //      delays will have passed by the time they may be granted).</span>
 542 |     | <span class='neutral'>    // Note: We don&#39;t simply add the shorter delay to the delayReductionLockTime</span>
 543 |     | <span class='neutral'>    //       because for legitimate use we may want to shorten the delay, say from</span>
 544 |     | <span class='neutral'>    //       2 days to 1 day, in this case we don&#39;t want to wait a total of 3 days.</span>
 545 |     | <span class='neutral'>    // This means that the delay used by default should include enough time to:</span>
 546 |     | <span class='neutral'>    //   -- Notice the change</span>
 547 |     | <span class='neutral'>    //   -- Deal with the security hole (remove attackers permissions)</span>
 548 |     | <span class='neutral'>    //   -- Adjust the delay back to a suitable value</span>
 549 |     | <span class='neutral'>    //   -- Cancel any proposals made during this period</span>
 550 | *   | <span class='executed'>    function changeDelay(uint256 _newDelay) public onlyRole(DEFAULT_ADMIN_ROLE) {</span>
 551 |     | <span class='neutral'>        // Only overwrite the same delay if there is a proposal we want to cancel</span>
 552 |     | <span class='neutral'>        // Delay must not more than 5 days (to avoid costly mistakes)</span>
 553 |     | <span class='unexecuted'>        if ((_newDelay == delay &amp;&amp; proposedDelay != 0) || _newDelay &gt; 5 days) {</span>
 554 |     | <span class='unexecuted'>            revert Errors.AccessControlDelayed_InvalidDelay();</span>
 555 |     | <span class='neutral'>        }</span>
 556 |     | <span class='neutral'></span>
 557 |     | <span class='unexecuted'>        if (block.timestamp &lt; delayReductionLockTime) {</span>
 558 |     | <span class='neutral'>            // The delay must already have been reduced because delayReductionLockTime is in the future</span>
 559 |     | <span class='neutral'>            // We can&#39;t have set the delay to proposedDelay yet, so we can just delete it</span>
 560 |     | <span class='unexecuted'>            delete delayReductionLockTime;</span>
 561 |     | <span class='unexecuted'>            delete proposedDelay;</span>
 562 |     | <span class='neutral'>        }</span>
 563 |     | <span class='neutral'></span>
 564 |     | <span class='unexecuted'>        if (_newDelay &gt;= delay) {</span>
 565 |     | <span class='neutral'>            // New delay is longer, just set it</span>
 566 |     | <span class='unexecuted'>            delay = _newDelay;</span>
 567 |     | <span class='neutral'>        } else {</span>
 568 |     | <span class='neutral'>            // New delay is shorter, enforce old delay until it is met</span>
 569 |     | <span class='unexecuted'>            delayReductionLockTime = block.timestamp + delay;</span>
 570 |     | <span class='unexecuted'>            proposedDelay = _newDelay;</span>
 571 |     | <span class='neutral'>        }</span>
 572 |     | <span class='neutral'>    }</span>
 573 |     | <span class='neutral'></span>
 574 |     | <span class='neutral'>    // an internal function that will return the timestamp to wait until,</span>
 575 |     | <span class='neutral'>    // foctors in the the delayReuctionLockTime</span>
 576 |     | <span class='neutral'>    // if after the lock time we can set delay to the new value</span>
 577 |     | <span class='unexecuted'>    function _getDelayTimestamp() internal returns (uint256) {</span>
 578 |     | <span class='unexecuted'>        if (block.timestamp &lt; delayReductionLockTime) {</span>
 579 |     | <span class='neutral'>            // We haven&#39;t reached the lock time yet,</span>
 580 |     | <span class='neutral'>            // We must wait until the greater of the lock time, or now + proposedDelay</span>
 581 |     | <span class='unexecuted'>            uint256 proposedDelayTime = block.timestamp + proposedDelay;</span>
 582 |     | <span class='unexecuted'>            return proposedDelayTime &gt; delayReductionLockTime ? proposedDelayTime : delayReductionLockTime;</span>
 583 |     | <span class='neutral'>        }</span>
 584 |     | <span class='neutral'>        // We have reached the lock time, we may set the delay to the proposed delay</span>
 585 |     | <span class='unexecuted'>        if (proposedDelay != 0) {</span>
 586 |     | <span class='unexecuted'>            delay = proposedDelay;</span>
 587 |     | <span class='unexecuted'>            delete proposedDelay;</span>
 588 |     | <span class='neutral'>        }</span>
 589 |     | <span class='unexecuted'>        return block.timestamp + delay;</span>
 590 |     | <span class='neutral'>    }</span>
 591 |     | <span class='neutral'></span>
 592 |     | <span class='neutral'>    function _checkProposalWaitTime(bytes32 proposalId) internal view returns (bool) {</span>
 593 |     | <span class='neutral'>        return block.timestamp &gt;= proposedRoles[proposalId];</span>
 594 |     | <span class='neutral'>    }</span>
 595 |     | <span class='neutral'></span>
 596 | *   | <span class='executed'>    function cancelRoleProposal(bytes32 role, address account) external virtual onlyRole(DEFAULT_ADMIN_ROLE) {</span>
 597 |     | <span class='unexecuted'>        if (proposedRoles[keccak256(abi.encodePacked(role, account))] == 0) {</span>
 598 |     | <span class='unexecuted'>            revert Errors.AdminVault_NotProposed();</span>
 599 |     | <span class='neutral'>        }</span>
 600 |     | <span class='unexecuted'>        delete proposedRoles[keccak256(abi.encodePacked(role, account))];</span>
 601 |     | <span class='neutral'>    }</span>
 602 |     | <span class='neutral'>}</span>
 603 |     | <span class='neutral'></span>

</code>
<br />

